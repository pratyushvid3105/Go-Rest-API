package utils

import (
	"errors"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

// SignedString needs a key that will be used for the signing process. And that key will then later also be used to verify incoming tokens. Therefore, here, we'll add a constant, secretKey, and we'll set this to some key, which in reality should be a bit more secret and hard to guess than this key here. But that's now the dummy secret key we'll use.
const secretKey = "supersecret"

func GenerateToken(email string, userId int64) (string, error) {
	// this NewWithClaims function now needs a method. And with that, it doesn't mean a function attached to a struct, but instead a method. So an identifier of the signing approach that should be used for signing that token, which is an important step because that signature can then be checked by that server in the future when clients send such a token to the server to verify that it's a valid token that was generated by this server.
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		// We should not include the password here. For security reasons, that should never be exposed anywhere.
		"email": email,
		"userId": userId,
		// And here we will use the Hour type or the Hour value and multiply that with 2 to make this token valid for two hours. And thereafter, it will expire and the client would have to sign in again. Then we actually should get this in the UNIX format, which we get by calling the Unix method in the end. And that will now set this exp key which will be used internally to make this token expire after this timeframe.
		"exp": time.Now().Add(time.Hour * 2).Unix(),
	})
	// NewWithClaims function will return a pointer to the token it produced. And then on that token, we can call the SignedString method because that token type we get back here is actually a more complex value. And we want to get a single string which we can send back to the client and which can then be attached to future requests by the client.
	return token.SignedString([]byte(secretKey))
}

func VerifyToken(token string) error {
	parsedToken, err := jwt.Parse(token, func(t *jwt.Token) (interface{}, error) {
		_, ok := t.Method.(*jwt.SigningMethodHMAC)

		if !ok {
			return nil, errors.New("unexpected signing method")
		}

		return secretKey, nil
	})

	if err != nil {
		return errors.New("could not parse token.")
	}

	tokenIsValid := parsedToken.Valid
	
	if !tokenIsValid {
		return errors.New("invalid token!")
	}

	// Now if we got a valid token, we can use our parsed token and access the Claims field to get hold of the data that was stored in that token. So the email and userId field. We wanna check whether the claims we got for this token is of the jwt.MapClaims type, which it should be if it's our token because we used that MapClaims type for including our data into the token. As a result, we'll get back the claims.
	// claims, ok := parsedToken.Claims.(jwt.MapClaims)

	// if !ok {
	// 	return errors.New("invalid token claims.")
	// }

	// email := claims["email"].(string)
	// userId := claims["userId"].(int64)
	return nil
}